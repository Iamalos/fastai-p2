# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_datasets.ipynb.

# %% ../nbs/05_datasets.ipynb 2
from __future__ import annotations
import math, numpy as np, matplotlib.pyplot as plt
from operator import itemgetter
from itertools import zip_longest
import fastcore.all as fc

from torch.utils.data import default_collate

from .training import *

# %% auto 0
__all__ = ['inplace', 'collate_dict', 'show_image', 'subplots', 'get_grid', 'show_images', 'DataLoaders']

# %% ../nbs/05_datasets.ipynb 41
def inplace(f):
    def _f(b):
        f(b)
        return b
    return _f

# %% ../nbs/05_datasets.ipynb 58
def collate_dict(ds):
    # import ipdb; ipdb.set_trace()
    # create a function (getter) to grab xs and ys
    get = itemgetter(*ds.features)
    # inner function to run getter on a collated dictionary
    def _f(b): return get(default_collate(b))
    return _f

# %% ../nbs/05_datasets.ipynb 65
@fc.delegates(plt.Axes.imshow)
def show_image(im, # image-like to show
               ax=None, # axes to show image on
               figsize=None, # size of a figure
               title=None, # titile of a figure
               noframe=True, # whether to show frame
               **kwargs):
    "Show a PIL or PyTorch image on ax"
    # check if image has tensor attributes
    # import ipdb; ipdb.set_trace()
    if im is None: return
    elif fc.hasattrs(im, ('cpu', 'permute', 'detach')):
        # detach and move to cpu
        im = im.detach().cpu()
        # if 3 dimensions and first dimension is less than 5: make channels last dimension:
        # (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
        # (M, N, 4): an image with RGBA values (0-1 float or 0-255 int), i.e. including transparency.
        if len(im.shape) == 3 and im.shape[0]<5: im = im.permute(1,2,0)
    # if not tensor and not itself ndarray - cast as ndarray
    elif not isinstance(im, np.ndarray): im = np.array(im)
    # remove channels if it is 1 (greyscale image)
    if im.shape[-1] == 1: im = im.squeeze(-1)
    # create ax if it is None using subplots
    if ax is None: _, ax = plt.subplots(figsize=figsize)
    # show image
    ax.imshow(im, **kwargs)
    # set title
    if title is not None: ax.set_title(title)
    # remove xticks and yticks
    ax.set_xticks([])
    ax.set_yticks([])
    # remove axis if noframe
    if noframe: ax.axis('off')
    return ax

# %% ../nbs/05_datasets.ipynb 70
@fc.delegates(plt.subplots, keep=True)
def subplots(
    nrows:int = 1, # Number of rows in returned axes grid
    ncols:int = 1, # Number of columns in returned axes grid
    figsize:tuple = None, # (width, height) in inches of the returned figure
    imsize:int = 3, # Size (in inches) of images that will be displayed
    suptitle:str = None, # Title to be set to returned figure
    **kwargs,
): # fig and axes
    " A figure and set of subplots to display images of `imsize` inches."
    # if figsize is not given, estimate it as ncols x imsize and nrows x imsize
    if figsize is None: figsize = (ncols * imsize), (nrows * imsize)
    # return figure and ax
    fig, ax = plt.subplots(nrows, ncols, figsize=figsize)
    # add suptitles
    if suptitle is not None: fig.suptitle(suptitle)
    # if we have a single image, create an array of it
    if nrows*ncols==1: ax = np.array([ax])
    return fig, ax

# %% ../nbs/05_datasets.ipynb 75
@fc.delegates(subplots)
def get_grid(
    n:int, # Number of axes
    nrows:int = None, # Number of rows, defaulting to `int(math.sqrt(n))`
    ncols:int = None, # Number of cols, defaulting to `ceil(n/rows)`
    title:str = None, # If passed, title set to the figure
    weight:str = 'bold', # Title font weight
    size:int = 14, # Title font size
    **kwargs,
): # fig and axs
    "Return a grid of `n` axes, `rows` by `cols`"
    # if nrows is provided find the necessary ncols
    if nrows: ncols = ncols or int(np.ceil(n/nrows))  
    # vice-versa to rows
    elif ncols: nrows = nrows or int(np.ceil(n/nrows)) # originally it was floor
    # if no rows and no cols, estimate rows and cols to make a square figure
    else:
        nrows = int(np.sqrt(n))
        ncols = int(np.ceil(n/nrows)) # originally it was floor
     # get figure and axes using our `subplots` method
    fig, axs = subplots(nrows, ncols, **kwargs)
    # remove axis for empty grid cells
    for i in range(n, nrows*ncols): axs.flat[i].set_axis_off()
    # add titles
    if title is not None: fig.suptitle(title, weight=weight, size=size)
    return fig, axs

# %% ../nbs/05_datasets.ipynb 81
@fc.delegates(subplots)
def show_images(ims: list, # Images to show
                nrows: int|None=None, # Number of rows in a grid
                ncols: int|None=None, # Number of columns in grid(auto-calculated if None)
                titles:list|None=None, # Optional list of titles for each image
                **kwargs
               ):
    axs = get_grid(len(ims), nrows, ncols, **kwargs)[1].flat
    # import ipdb; ipdb.set_trace()
    for im, t, ax in zip_longest(ims, titles, axs): show_image(im, ax=ax, title=t)

# %% ../nbs/05_datasets.ipynb 86
class DataLoaders: 
    def __init__(self, *dls): self.train, self.valid = dls[:2]
    
    @classmethod
    def from_dd(cls, dd, batch_size, as_tuple=True, **kwargs):
        f = collate_dict(dd['train'])
        return cls(*get_dls(*dd.values(), bs=batch_size, collate_fn=f, **kwargs))
